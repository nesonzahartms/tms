'''
List/Dict comprehensions, Generator expressions
'''

import sys

'''1. List comprehension (списковое включение) – выражение, позвояющее сгенерировать новый объект списка на основании 
уже имеющейся последовательности данных в одну строку'''

sequence = range(1, 11)  # последовательность целых чисел от 1 до 10

''' 
ПРИМЕРЫ:

Генерация нового списка, используя обычный цикл for и добавление нового элемента в список '''

result = []  # создаем пустой список, который нужно будет заполнить
for x in sequence:  # бежим циклом по нашей последовательности
    result.append(x)  # добавляем элемент последовательности в конец списка

print(result)

''' Аналог с использованием List comprehension: '''
result = [x for x in sequence]
print(result)

''' Поддерживают фильтрацию по условию (Постфиксная запись условия): '''
result = [x for x in sequence if x % 2 == 0]
print(result)
# идет после for, и else написать в постфиксном условии НЕЛЬЗЯ!
# в результат попадут только четные числа:
# [2, 4, 6, 8, 10]

'''Префиксная запись условия: поддерживается тернарный оператор if/else '''

result = [x if x % 2 == 0 else 0 for x in sequence]
print(result)
# Нечетные числа будут заменены на 0, четные останутся как есть:
# [0, 2, 0, 4, 0, 6, 0, 8, 0, 10]

'''
ЗАПОМИНАЕМ:
- ПРЕФИКСНАЯ ЗАПИСЬ (ДО цикла for):
  - преобразование элементов из исходной последовательности в зависимости от условия, 
  - поддерживает else

- ПОСТФИКСНАЯ ЗАПИСЬ (ПОСЛЕ цикла for):
  - фильтрация элементов из исходной последовательности в зависимости от условия, 
  - НЕ поддерживает else 
'''

''' Пример list comprehension в связке c enumerate: '''
list1 = list(range(1, 11))
list2 = list(range(11, 21))

# хотим получить список пар, где первый элемент пары – это элемент списка list1, второй элемент пары – элемент списка
# list2 (списки равной длины, это ВАЖНО!)
result = [(element, list2[idx]) for idx, element in enumerate(list1)]
print(result)
# [(1, 11), (2, 12), (3, 13), (4, 14), (5, 15), (6, 16), (7, 17), (8, 18), (9, 19), (10, 20)]

'''
2. Dict comprehension (словарное включение) – выражение, позвояющее сгенерировать новый объект словаря на основании уже 
имеющейся последовательности данных (или другого словаря) в одну строку'''

'''
ПРИМЕРЫ:
Генерация нового словаря из последовательности целых чисел, где ключ словаря – строка ‘TEST’ + число последовательности,
а значение по ключу – само число последовательности'''

new_dict = {f'KEY_{x}': x for x in range(1, 11)}
new_dict2 = {f'NEW_{k}': v * 10 for k, v in new_dict.items()}
print(new_dict)

'''
SET COMPREHENSION
'''

new_set = {i for i in range(1, 51)}

'''
GENERATOR EXPRESSION
'''
big_range = range(1000_000)
list_ = [i for i in big_range]  # в таких случаях лучше использовать: list(range(...))
set_ = {i for i in big_range}
tuple_ = tuple(list_)
generator_ = (i for i in big_range)

for object_ in list_, set_, tuple_, generator_:
    size_in_bytes = sys.getsizeof(object_)
    print(size_in_bytes)

'''
- ГЕНЕРАТОРЫ нужны чтобы сэкономить память, если нам не нужно хранить все объекты одновременно
- Пройтись циклом по Генератору можно только 1 раз, после чего Генератор будет "пустым"
- У Генератора нельзя получить элемент ПО ИНДЕКСУ
- * Оператор in работает с генераторами, с той разницей (между списками/множествами), 
  что после нахождения искомого элемента, сам этот элемент, 
  а также ВСЕ элементы, которые были "просмотрены" в процессе поиска искомого элемента,
  "выходят" из генератора

'''

gen = (i for i in range(10))
print(5 in gen)
print(list(gen))